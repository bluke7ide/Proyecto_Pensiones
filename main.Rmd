---
title: "Proyecto - Pensiones I"
author: 
  - Luis Fernando Amey Apuy - C20470
  - Javier Hernández Navarro - C13674
  - Anthony Mauricio Jiménez Navarro - C24067
  - Gustavo Alberto Amador Fonseca - C20459
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    self_contained: true
    highlight: tango
---
# Librerías e importaciones
```{r, warning=FALSE, message=FALSE}
source("cod/setup.R")
source("cod/load_database.R")
```

# Tomar los trabajadores activos
```{r}
ultimo_año <- data.frame(activo = rowSums(BD_Cotizantes %>%
                                select(tail(names(.), 12)) > 0)>0)
```

# Gráficos de CDR
## Estructura de la población
```{r}
cotizantes <- BD_Cotizantes %>% 
  select(2,3) %>% 
  mutate(estado = ultimo_año$activo)
pensionados <- BD_Pensionados %>% 
  select(4,5) %>% 
  mutate(estado = 2)
names(pensionados) <- names(cotizantes)
poblacion <- rbind(cotizantes, pensionados) %>% 
  mutate(edad = 2024 - year(Fec.Nac)) %>% 
  select(-1)
names(poblacion) <- tolower(names(poblacion))
poblacion[poblacion$sexo == "1",]$sexo <- "M"
poblacion[poblacion$sexo == "2",]$sexo <- "F"
cotizantes <- poblacion[1:5196,]
pensionados <- poblacion[5197:5561,]
```

```{r}
# Crear grupos de edad
df <- poblacion %>%
  mutate(grupo_edad = cut(
    edad,
    breaks = seq(0, 100, by = 5),
    right = FALSE,
    labels = paste(seq(0, 95, by = 5), seq(4, 99, by = 5), sep = "-")
  ))

# Agrupar por grupo de edad y sexo
df_piramide <- df %>%
  group_by(grupo_edad, sexo) %>%
  summarise(poblacion = n(), .groups = "drop") %>%
  mutate(poblacion = ifelse(sexo == "M", -poblacion, poblacion))

fig <- ggplot(df_piramide, aes(x = grupo_edad, y = poblacion, fill = sexo)) +
  geom_bar(stat = "identity", width = 0.9) +
  coord_flip() +
  scale_y_continuous(
    labels = abs,
    limits = c(-1, 1) * max(abs(df_piramide$poblacion))
  ) +
  labs(
    x = "Grupo de Edad",
    y = "Población",
    fill = "Sexo"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )

# ggsave("res/piramide.pdf", fig)


```

```{r}
df <- poblacion %>%
  mutate(
    sexo = recode(sexo, "M" = "Hombre", "F" = "Mujer"),
    estado = recode_factor(
      as.character(estado),
      "1" = "Activo",
      "0" = "No activo",
      "2" = "Pensionado"
    )
  )

# Agrupación por sexo
sexo_df <- df %>%
  count(categoria = sexo) %>%
  mutate(grupo = "Sexo")

# Agrupación por estado
estado_df <- df %>%
  count(categoria = estado) %>%
  mutate(grupo = "Estado")

resumen <- bind_rows(sexo_df, estado_df)

colores <- c(
  "Hombre" = "#377EB8",
  "Mujer" = "#984EA3",
  "Activo" = "#4DAF4A",
  "No activo" = "#FF7F00",
  "Pensionado" = "#999999"
)


fig <- ggplot(resumen, aes(x = grupo, y = n, fill = categoria)) +
  geom_bar(stat = "identity", position = "stack", width = 0.6) +
  geom_text(aes(label = n), position = position_stack(vjust = 0.5), color = "black", size = 4) +
  scale_fill_manual(values = colores) +
  labs(
    x = NULL,
    y = "Cantidad de Personas",
    fill = NULL
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    legend.position = "right"
  )

# ggsave("res/resumen_pob.pdf", fig)

```

## Población activa
```{r}
cotizantes_activos <- cotizantes[cotizantes$estado == 1, ]

bar_totals <- cotizantes_activos %>%
  count(edad) %>%
  mutate(
    mitad = n / 2,
    edad = factor(edad)  
  )


fig <- ggplot(cotizantes_activos, aes(x = factor(edad), fill = sexo)) +
  geom_bar(position = "stack") +
  # Línea horizontal en la mitad de cada barra
  geom_segment(
    data = bar_totals,
    aes(x = edad, xend = edad, y = mitad - 0.5, yend = mitad + 0.5),
    inherit.aes = FALSE,
    color = "black",
    linewidth = 3
  ) +
  scale_x_discrete(
  breaks = as.character(seq(min(cotizantes_activos$edad), max(cotizantes_activos$edad), by = 5))
  ) +
  labs(
    x = "Edad",
    y = "Cantidad de cotizantes activos"
  ) +
  theme_minimal() 

# ggsave("res/dist_activos.pdf", fig)
```


```{r}
cotizantes <- cotizantes %>% 
  mutate(antiguedad = apply(BD_Cotizantes[, 4:ncol(BD_Cotizantes)], 1, function(x) which(x != 0)[1]))
cotizantes$antiguedad <- 2024 - year(as_datetime(names(BD_Cotizantes)[cotizantes$antiguedad+3]))
```

```{r}
fig <- ggplot(cotizantes, aes(x = antiguedad, fill = sexo)) + 
  geom_bar(position = "stack") +
  labs(
    x = "Años de antiguedad en el régimen",
    y = "Cantidad de personas"
  ) +
  theme_minimal()

# ggsave("res/activos_ant.pdf", fig)
```


## Población pensionada
```{r}
bar_totals <- pensionados %>%
  count(edad) %>%
  mutate(
    mitad = n / 2,
    edad = factor(edad) 
  )

fig <- ggplot(pensionados, aes(x = factor(edad), fill = sexo)) +
  geom_bar(position = "stack") +
  scale_x_discrete(
  breaks = as.character(seq(min(pensionados$edad), max(pensionados$edad), by = 5))
  ) +
  labs(
    x = "Edad",
    y = "Cantidad de cotizantes activos"
  ) +
  theme_minimal() 
# ggsave("res/dist_pensionados.pdf", fig)
```

```{r}
pensionados <- pensionados %>% 
  mutate(antiguedad = 2024 - year(BD_Pensionados$`Rige de la Pensión`))
fig <- ggplot(pensionados, aes(x = antiguedad, fill = sexo)) + 
  geom_bar(position = "stack") +
  labs(
    x = "Años pensionado",
    y = "Cantidad de pensionados"
  ) +
  theme_minimal() 
# ggsave("res/pensionados_ant.pdf", fig)
```

## Comportamiento de altas y bajas de afiliados
```{r}
n_meses <- ncol(BD_Cotizantes) - 3

# cuántas ventanas de 12 meses podemos formar
n_periodos <- n_meses - 12 + 1
if(n_periodos < 1) stop("¡No hay suficientes meses para formar un año completo!")

# Preparamos un objeto para guardar los indicadores
activo <- matrix(0L, 
                 nrow = nrow(BD_Cotizantes), 
                 ncol = n_periodos)

# Recorremos cada “ventana” de 12 meses
for(k in seq_len(n_periodos)){
  cols_k <- (3 + k):(3 + k + 11)    # e.g. para k=1, cols 4:15; para k=2, 5:16; etc.
  submat  <- BD_Cotizantes[, cols_k]
  
  # fila i = 1 si en esos 12 meses hubo al menos 1 >0
  activo[, k] <- as.double(rowSums(submat > 0) > 0)
}

# Ponemos nombres a cada periodo (opcional)
colnames(activo) <- colnames(BD_Cotizantes)[15:363]

# Finalmente, volcamos en comportamientos
# (aquí asumo que quieres mantener las 3 primeras columnas y luego estos indicadores)
comportamientos <- cbind(
  BD_Cotizantes[, 1:3],
  as.data.frame(activo)
)
```

```{r}
afiliados <- data.frame(fecha = colnames(BD_Cotizantes)[15:363], activos = colSums(activo))
fig <- ggplot(afiliados, aes(x = fecha, y = activos)) + 
  scale_x_discrete(breaks = afiliados$fecha[seq(1, nrow(afiliados), by = 60)]) +
  geom_point(color = 'purple') +
    labs(
    x = "Fecha",
    y = "Cantidad de afiliados"
  ) +
  theme_minimal() 
# ggsave("res/comportamiento.pdf", fig)
```

```{r}
diffs <- activo[, -1, drop = FALSE] - activo[, -ncol(activo), drop = FALSE]

Altas     <- colSums(diffs ==  1)  # pasó de 0 a 1
Bajas     <- colSums(diffs == -1)  # pasó de 1 a 0

resultado <- data.frame(
  fecha     = colnames(BD_Cotizantes)[16:363],
  Altas     = Altas,
  Bajas     = Bajas,
  Afiliados = colSums(activo)[2:349],
  row.names = NULL
)

```

```{r}
rm(activo,
   afiliados, 
   bar_totals,
   comportamientos,
   cotizantes,
   cotizantes_activos,
   df,
   df_piramide,
   diffs,
   estado_df, 
   fig,
   pensionados,
   poblacion,
   resultado,
   resumen,
   sexo_df,
   submat,
   Altas, 
   Bajas, 
   colores,
   cols_k,
   k,
   n_meses,
   n_periodos, 
   invalidez)
```

# Preparación Balance
## Población general
```{r}
cotizantes <- BD_Cotizantes %>% select(Fec.Nac, Sexo)
names(cotizantes) <- c('fecha_nac', 'sexo')
pensionados <- BD_Pensionados %>% select(FEC_NAC, SEXO)
names(pensionados) <- c('fecha_nac', 'sexo')
pensionados <- pensionados  %>%
  mutate(sexo = ifelse(sexo == "M", 1, 2))
poblacion <- rbind(cotizantes, pensionados) 
poblacion <- poblacion %>% mutate(
  edad = 2024 - year(poblacion$fecha_nac)
)
cuentas <- poblacion %>% count(sexo,edad)
unicos <- cuentas %>% select(sexo, edad)
```

```{r}
pensionados <- pensionados %>% mutate(
  edad = 2024 - year(pensionados$fecha_nac),
  meses = 12 - month(pensionados$fecha_nac)
)
cotizantes <- cotizantes %>% mutate(
  edad = 2024 - year(cotizantes$fecha_nac),
  meses = 12 - month(cotizantes$fecha_nac)
)
cotizaciones <- BD_Cotizantes %>% select(-1,-2,-3)
pensionados <- cbind(pensionados, BD_Pensionados) 
pensionados <- pensionados %>% select(-c(4,7,8))
pensionados <- pensionados %>% mutate(
  edad = 2024 - year(pensionados$fecha_nac)
)

niveles <- 110.39017/IPC$Nivel[229:588]
```



```{r}
rm(BD_Cotizantes,
   BD_Pensionados,
   BD_Financiero,
   ultimo_año,
   poblacion, 
   IPC, 
   cuentas
   )
```

## Propiedades de cotización
```{r}
cot_prop <- function(){
  # Tomando el valor presente
  vp_cot <- sapply(1:ncol(cotizaciones), function(x) t(cotizaciones[,x]) * niveles[[x]])
  
  # Salarios más de 10 mil cuentan como cotizaciones
  data <- vp_cot > 10000
  does_cot <- sapply(1:nrow(data), function(x) which(data[x,]))
  inicios <- sapply(1:nrow(data), function(x) first(does_cot[[x]]))
  
  # Cantidad de cuotas
  cuotas <- rowSums(data)
  
  # Densidades de cotización
  dens_cot <- sapply(1:nrow(data), function(x) 
    mean(data[x,inicios[x]:ncol(data)]))
  
  # Promedio de los 300 mejores salarios
  cot_pen <- vp_cot < 5e6
  
    # a menos de que históricamente haya cotizado 5m, se veta
  true_counts <- rowSums(1 - cot_pen)/cuotas > 0.5 # al menos más de la mitad 
  cot_pen[true_counts,] <- TRUE
  
    # Se fusionan las condiciones
  cot_pen <- cot_pen & data
  calc_pen <- sapply(1:nrow(data), function(x) vp_cot[x, cot_pen[x,]])
  
    # Cálculo explícito
  Sx <- sapply(1:nrow(data), function(x) 
    mean(head(sort(calc_pen[[x]], decreasing = T), 300)))
  
  return(data.frame(densidades = dens_cot, sal_prom = Sx, cuotas = cuotas))
}
```

```{r}
cotizantes <- cbind(cotizantes, cot_prop())
```

## Localización probabilidades
```{r}
find_qx <- function(x, sexo, año){
  return(SUPEN[which(SUPEN$sex == sexo & SUPEN$year == año & SUPEN$edad == x),6])
}

find_qix <- function(x, sexo, año){
  return(invalidez[invalidez$Edad == x & invalidez$sexo == sexo, 3])
}

```

```{r}
año <- 2025
all_qx <- list(
  sapply(0:95, function(y) sapply(0:115, function(x) find_qx(x, 1, año+y))),
  sapply(0:95, function(y) sapply(0:115, function(x) find_qx(x, 2, año+y))))
```

## Cotizaciones mínimas de invalidez
```{r}
cot_min_inv <- function(x) 12 + min(max(x-24, 0), 18)*4 + min(max(0, x-42), 6)*6
sapply(0:115, cot_min_inv)
```

## Porcentajes de viudez
```{r}
porcentaje_viudez <- function(x){
  if(x < 50){
    porc_viu <- c(rep(0.5, 50-x), rep(0.6, 10), rep(0.7, 115-60))
  } else if(x < 60){
    porc_viu <- c(rep(0.6, 60-x), rep(0.7, 115-60))
  } else {
    porc_viu <- c(rep(0.7, 115-x))
  }
  return(porc_viu)
}
```

```{r}
cotizacion_minima <- function(x, sexo){
  cot_min <- 300
  edad_min <- 65
  if(sexo == 2){
    if(x == 64){
      edad_min <- 64
      cot_min <- 357
    }
    if(x == 63){
      cot_min <- 405
      edad_min <- 63
    }
  }
  return(c(cot_min, edad_min))
}
```


```{r}
source("cod/porc_pensiones.R")
```

```{r}
# curv_sal <- rep(1, 20:115)
```


```{r}
prueba <- function(int, inf){
  int_ef <- ((1+int)/(1+inf))^(1/12) 
  anual <- (1 - int_ef^-12)/(int_ef-1)
  # SEM <- cotizantes$sal_prom*anual*0.0085
  # pen_anual <- cotizantes$sal_prom*(anual + int_ef^(-11/12)) 
  years <- 0:94

  # Doble iteración para recorrer toda la data, individuos y años
  for(id in 1:5196){
    x <- cotizantes$edad[id]
    sexo <- cotizantes$sexo[id]
    dens <- cotizantes$densidades[id]
    cuota_ini <- cotizantes$cuotas[id]
    first_pen <- T
    per <- data.frame(act = rep(0, 95), inv = 0, pen = 0, viu = 0, orp = 0)
    porc_viu <- porcentaje_viudez(x)
    per$act[1] <- 1
    for(j in years){
      if(x + j > 115){ # ya no puede vivir
        break
      }
      # Preliminares 
      qx <- all_qx[[sexo]][x,j]
      px <- 1-qx
      v_px <- all_qx[[3-sexo]][x,j]
      qix <- all_qix[[sexo]][x-19]
      pix <- 1 - qix
      cot_min <- cotizacion_minima(x+j, sexo)
      n_cot <- cuota_ini + j*dens
      ncot180 <- n_cot >= 180
      
      per$act[j+2] <- per$act[j+1]*px*pix
 
      # Invalidez
      if(ncot180 | (dens >= 0.5 & cot_min_inv(x+j))){
        per$inv[j+2] <- per$act[j+1]*qix + per$inv[j+1]*px # 3
      } else if(n_cot>=60 & dens >= 0.5){
        porc_invp <- n_cot/180
        per$inv[j+2] <- per$act[j+1]*qix*porc_invp + per$inv[j+1]*px # 3
      } else {
        per$inv[j+2] <- per$inv[j+1]*px
      }      
           
      # Vejez
      if(n_cot >= cot_min[1] & x+j >= cot_min[2]){
        if(first_pen){
          first_pen <- F
          ini_cot <- n_cot
          cot_ad <- (ini_cot-300)/1200
        }
        cot_post <- max(0, n_cot - ini_cot)*2/1500
        porc_pen <- min(1.25, 1+cot_ad +cot_post)
        per$act[j+2] <- per$act[j+2]*0.1
        per$pen[j+2] <- per$act[j+1]*0.9*porc_pen + per$pen[j+1]*px # 3
        
      } else if(ncot180 & x+j >= 65) {
        porc_penp <- n_cot/300
        per$act[j+2] <- per$act[j+2]*0.1 # puede seguir trabajando 
        per$pen[j+2] <- per$act[j+1]*0.9*porc_penp + per$pen[j+1]*px # 3
      } else {
        per$pen[j+2] <- per$pen[j+1]*px
      }
      
      # Sucesión
      cond_hij <- x+j-25 < 25 & x+j-25 >=0 # esta última para ver si nació
      ind_suc <- 2
      if(ncot180 | dens >= 0.5){
        ind_suc <- 1
      } 
      per$viu[j+2] <- per$viu[j+1]*v_px + per[j+1, ind_suc:3]*qx # 1
      if(cond_hij){
        o_px <- 1 - 0.5*(all_qx[[1]][x-25,j] + all_qx[[2]][x-25,j])
        per$orp[j+2] <- per$orp[j+1]*o_px + per[j+1, ind_suc:3]*qx # 2
      }
    }
    
    # Faltan:
    # 1. porcentajes esposa
    # 2. porcentajes hijo
    # 3. Monto de pensión
    
  }
  
}
```

```{r}
t <- proc.time()
prueba(0.05, 0.02)
proc.time() - t
```
























